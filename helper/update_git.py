import os
import subprocess
import logging
from typing import Optional

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


class GitPusher:
    """
    Encapsulates a simple `git pull --rebase` + `git push` workflow.

    Usage:
        pusher = GitPusher(repo_path="/path/to/your/repo")
        pusher.push(remote="origin", branch="main")

    Behavior:
    1. If there are uncommitted changes, stage and commit them with an autogenerated message.
    2. Pull from <remote>/<branch> using --rebase (to avoid merge commits).
    3. Push to <remote>/<branch>.
    """

    def __init__(self, repo_path: Optional[str] = None):
        """
        :param repo_path: Path to the Git repository. If None, use the current working directory.
        """
        if repo_path is None:
            repo_path = os.getcwd()
        self.repo_path = os.path.abspath(repo_path)
        logger.debug(f"GitPusher initialized for repo at: {self.repo_path}")

    def _run_command(self, cmd: list[str]) -> str:
        """
        Run a command via subprocess.run, raise on failure.

        :param cmd: List of command tokens, e.g. ["git", "status", "--porcelain"].
        :return: Stdout of the command (stripped).
        :raises RuntimeError: If the command exits with a nonzero code.
        """
        logger.debug(f"[GitPusher] Running: {' '.join(cmd)} (cwd={self.repo_path})")
        try:
            result = subprocess.run(
                cmd,
                cwd=self.repo_path,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True,
            )
        except subprocess.CalledProcessError as e:
            msg = e.stderr.strip() or e.stdout.strip()
            logger.error(f"[GitPusher] Command failed ({' '.join(cmd)}): {msg}")
            raise RuntimeError(f"Command {' '.join(cmd)} failed: {msg}") from e

        output = result.stdout.strip()
        if output:
            logger.debug(f"[GitPusher] Output: {output}")
        return output

    def _commit_local_changes(self) -> None:
        """
        Check for uncommitted changes. If any, stage and commit with an autogenerated message.
        """
        # 1) Detect uncommitted changes via 'git status --porcelain'
        status_output = self._run_command(["git", "status", "--porcelain"])
        if not status_output:
            logger.info("[GitPusher] No local changes to commit.")
            return

        logger.info("[GitPusher] Detected uncommitted changes. Staging & committing...")
        # Stage all changes
        self._run_command(["git", "add", "."])

        # Autogenerated commit message
        user = os.getenv("USER") or os.getenv("USERNAME") or "<user>"
        timestamp = self._run_command(["date", "+%Y-%m-%dT%H:%M:%S"])
        commit_msg = f"autocommit: {user} @ {timestamp}"
        self._run_command(["git", "commit", "-m", commit_msg])
        logger.info("[GitPusher] Local changes committed with message: %s", commit_msg)

    def pull(self, remote: str = "origin", branch: str = "main") -> None:
        """
        Pull upstream changes from <remote>/<branch>.
        """
        logger.info("[GitPusher] Pulling new change")
        self._run_command(["git", "pull"])
        logger.info("[GitPusher] Pull successful.")

    def push(self, remote: str = "origin", branch: str = "main") -> None:
        """
        1. Commit any local changes.
        2. Pull --rebase from <remote>/<branch>.
        3. Push to <remote>/<branch>.

        :param remote: Git remote name (default "origin").
        :param branch: Branch to push (default "main").
        :raises RuntimeError: If any Git command fails.
        """
        # 1) Commit local changes (if present)
        self._commit_local_changes()

        # 2) Push to the remote branch
        logger.info("[GitPusher] Pushing to %s/%s", remote, branch)
        self._run_command(["git", "push", remote, branch])
        logger.info("[GitPusher] Push successful.")
